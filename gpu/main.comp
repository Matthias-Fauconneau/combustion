#version 460
double sq(double x) { return x*x; }
double log(double x) { return double(log(float(x))); }
double pow(double x, double y) { return double(pow(float(x), float(y))); }

double dot(double[5] a, double[5] b) { double sum = 0.; for(uint k=0;k<a.length();k++) { sum += a[k]*b[k]; } return sum; }
double eval_poly(double[5] P, double x) {
	double[5] generate_k; for(uint k=0;k<generate_k.length();k++) generate_k[k] = pow(x, k);
	return dot(P, generate_k);
}

const uint S = SPECIES;

double dot(double[S] a, double[S] b) { double sum = 0.; for(uint k=0;k<a.length();k++) { sum += a[k]*b[k]; } return sum; }

struct TransportPolynomials {
	double[S][5] sqrt_viscosity_T14;
	double[S][5] thermal_conductivity_T12;
	double[S][S][5] binary_thermal_diffusion_coefficients_T32;
};

struct Species {
	double[S] molar_mass;
	double[S][2][7] thermodynamics;
	TransportPolynomials transport_polynomials;
};
const Species species =
#include "species.h"
;
const double volume = 1.;

double sqrt_viscosity(uint a, double T) { return sqrt(sqrt(T)) * eval_poly(species.transport_polynomials.sqrt_viscosity_T14[a], log(T)); }
double thermal_conductivity(uint a, double T) { return sqrt(T) * eval_poly(species.transport_polynomials.thermal_conductivity_T12[a], log(T)); }
double binary_thermal_diffusion_coefficient(uint a, uint b, double T) { return pow(T,3./2.) * eval_poly(species.transport_polynomials.binary_thermal_diffusion_coefficients_T32[a>b?a:b][a>b?b:a], log(T)); }

layout(push_constant) uniform Constants {
double pressure_R;
} constants;
layout(set = 0, binding = 0) buffer Temperature { double data[]; } temperature;
layout(set = 0, binding = 1) buffer Amount { double data[]; } _amounts[S/*-1*/];
layout(set = 0, binding = 2) buffer d_Temperature { double data[]; } d_temperature;
layout(set = 0, binding = 3) buffer d_Amount { double data[]; } d_amounts[S-1];
layout(set = 0, binding = 4) buffer Viscosity { double data[]; } viscosity;
layout(set = 0, binding = 5) buffer ThermalConductivity { double data[]; } _thermal_conductivity;
layout(set = 0, binding = 6) buffer MixtureAveragedThermalDiffusionCoeffficent { double data[]; } mixture_averaged_thermal_diffusion_coefficients[S];

void main() {
	uint i = gl_GlobalInvocationID.x;
	double T = temperature.data[i];
	double[S] amounts; for(int k=0;k<amounts.length();k++) amounts[k] = _amounts[k].data[i];
	double[S] generate_k; for(uint k=0;k<generate_k.length();k++) {
		double[S] generate_j;
		for(uint j=0;j<generate_j.length();j++) {
			generate_j[j] = sq(1. + (sqrt_viscosity(k, T)/sqrt_viscosity(j, T)) * sqrt(sqrt(species.molar_mass[j]/species.molar_mass[k]))) /
				(sqrt(8.) * sqrt(1. + species.molar_mass[k]/species.molar_mass[j]));
		}
		generate_k[k] = sq(sqrt_viscosity(k, T)) / dot(amounts, generate_j);
	}
	viscosity.data[i] = dot(amounts, generate_k);
	double amount = constants.pressure_R * volume / T; // pressure/NA * volume / (K * T)
	double[S] thermal_conductivities; for(uint k=0;k<thermal_conductivities.length();k++) { thermal_conductivities[k] = thermal_conductivity(k, T); }
	double[S] rcp_thermal_conductivities; for(uint k=0;k<rcp_thermal_conductivities.length();k++) { rcp_thermal_conductivities[k] = 1. / thermal_conductivity(k, T); }
	_thermal_conductivity.data[i] = 1./2. * (dot(amounts, thermal_conductivities) / amount + amount / dot(amounts, rcp_thermal_conductivities));
	for(uint k=0;k<mixture_averaged_thermal_diffusion_coefficients.length();k++) {
		double[S] generate_j;
		for(uint j=0;j<generate_j.length();j++) {
			if (j != k) {
				generate_j[j] = 1. / binary_thermal_diffusion_coefficient(k, j, T);
			} else {
				generate_j[j] = 0.;
			}
		}
		mixture_averaged_thermal_diffusion_coefficients[k].data[i]  = (1. - amounts[k]/amount) / dot(amounts, generate_j);
	}
}

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;
